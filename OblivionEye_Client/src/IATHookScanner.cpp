#include "../include/IATHookScanner.h"
#include <windows.h>
#include <psapi.h>
#include <imagehlp.h>
#include <vector>
#include <set>
#include <thread>
#include <chrono>
#include <algorithm>
#include <fstream>
#include "../include/Logger.h"
#include "../include/ProcessWatcher.h"
#include "../include/Config.h"
#include "../include/DetectionController.h"
#include "../include/SleepUtil.h"

#pragma comment(lib, "psapi.lib")
#pragma comment(lib, "imagehlp.lib")

static const char* IAT_LOG_PREFIX = "[IAT]";

static bool GetModuleInfoSafe(HMODULE hMod, MODULEINFO &out) { memset(&out,0,sizeof(out)); if(!hMod) return false; return !!GetModuleInformation(GetCurrentProcess(),hMod,&out,sizeof(out)); }
static bool PtrInModule(HMODULE hMod, const void* p, size_t len=1){ MODULEINFO mi; if(!GetModuleInfoSafe(hMod,mi)) return false; uintptr_t base=(uintptr_t)mi.lpBaseOfDll; uintptr_t end=base+mi.SizeOfImage; uintptr_t addr=(uintptr_t)p; return addr>=base && (addr+len)<=end; }
static PIMAGE_NT_HEADERS GetNtHeaders(HMODULE hMod){ if(!hMod) return nullptr; if(!PtrInModule(hMod,hMod,sizeof(IMAGE_DOS_HEADER))) return nullptr; auto dos=(PIMAGE_DOS_HEADER)hMod; if(dos->e_magic!=IMAGE_DOS_SIGNATURE) return nullptr; auto nt=(PIMAGE_NT_HEADERS)((BYTE*)hMod+dos->e_lfanew); if(!PtrInModule(hMod,nt,sizeof(IMAGE_NT_HEADERS))) return nullptr; if(nt->Signature!=IMAGE_NT_SIGNATURE) return nullptr; return nt; }

std::string GetModuleName(HMODULE hModule){ char moduleName[MAX_PATH]; if(GetModuleFileNameExA(GetCurrentProcess(),hModule,moduleName,MAX_PATH)){ std::string fullPath(moduleName); size_t pos=fullPath.find_last_of("\\/"); if(pos!=std::string::npos) return fullPath.substr(pos+1); return fullPath;} return "UnknownModule"; }
std::vector<HMODULE> GetAllProcessModules(){ std::vector<HMODULE> m; HMODULE hMods[1024]; DWORD cb; if(EnumProcessModules(GetCurrentProcess(),hMods,sizeof(hMods),&cb)){ DWORD n=cb/sizeof(HMODULE); for(DWORD i=0;i<n;i++) m.push_back(hMods[i]); } return m; }
std::string GetModuleNameFromAddress(FARPROC address,const std::vector<HMODULE>& mods){ for(auto& h:mods){ MODULEINFO mi; if(GetModuleInformation(GetCurrentProcess(),h,&mi,sizeof(mi))){ uintptr_t a=(uintptr_t)address; uintptr_t b=(uintptr_t)mi.lpBaseOfDll; uintptr_t e=b+mi.SizeOfImage; if(a>=b && a<e) return GetModuleName(h); } } return "Unknown"; }

std::vector<SuspiciousIATEntry> ScanModuleIAT(HMODULE hModule){ std::vector<SuspiciousIATEntry> out; auto nt=GetNtHeaders(hModule); if(!nt) return out; ULONG size=0; auto* iidBase=(IMAGE_IMPORT_DESCRIPTOR*)ImageDirectoryEntryToData(hModule,TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT,&size); if(!iidBase || size<sizeof(IMAGE_IMPORT_DESCRIPTOR)) return out; auto* iid=iidBase; auto* iidEnd=(IMAGE_IMPORT_DESCRIPTOR*)((BYTE*)iidBase+size); auto allMods=GetAllProcessModules(); std::string moduleName=GetModuleName(hModule); while(!DetectionController::IsStopRequested() && iid && iid<iidEnd && iid->Name){ if(!PtrInModule(hModule,iid,sizeof(IMAGE_IMPORT_DESCRIPTOR))) break; auto nt2=GetNtHeaders(hModule); if(!nt2) break; char* importedModuleName=(char*)ImageRvaToVa(nt2,hModule,iid->Name,nullptr); if(!importedModuleName || !PtrInModule(hModule,importedModuleName)) { iid++; continue; } std::string importedModName(importedModuleName); std::transform(importedModName.begin(),importedModName.end(),importedModName.begin(),::tolower); auto* oft=(IMAGE_THUNK_DATA*)ImageRvaToVa(nt2,hModule,iid->OriginalFirstThunk,nullptr); auto* ft=(IMAGE_THUNK_DATA*)ImageRvaToVa(nt2,hModule,iid->FirstThunk,nullptr); if(!oft||!ft) { iid++; continue; } if(!PtrInModule(hModule,oft)||!PtrInModule(hModule,ft)){ iid++; continue; } while(!DetectionController::IsStopRequested() && oft->u1.AddressOfData){ if(!PtrInModule(hModule,oft,sizeof(IMAGE_THUNK_DATA))||!PtrInModule(hModule,ft,sizeof(IMAGE_THUNK_DATA))) break; std::string functionName="UnknownFunction"; if(!(oft->u1.Ordinal & IMAGE_ORDINAL_FLAG)){ auto* iibn=(IMAGE_IMPORT_BY_NAME*)ImageRvaToVa(nt2,hModule,oft->u1.AddressOfData,nullptr); if(iibn && PtrInModule(hModule,iibn,sizeof(IMAGE_IMPORT_BY_NAME)) && PtrInModule(hModule,iibn->Name)) functionName=(char*)iibn->Name; } else functionName="Ordinal_"+std::to_string(IMAGE_ORDINAL(oft->u1.Ordinal)); FARPROC currentAddress=(FARPROC)ft->u1.Function; HMODULE hExpected=GetModuleHandleA(importedModuleName); bool isHooked=false; std::string hookedModuleName="Unknown"; if(hExpected){ MODULEINFO mi; if(GetModuleInformation(GetCurrentProcess(),hExpected,&mi,sizeof(mi))){ uintptr_t addr=(uintptr_t)currentAddress; uintptr_t start=(uintptr_t)mi.lpBaseOfDll; uintptr_t end=start+mi.SizeOfImage; if(addr<start || addr>=end){ isHooked=true; hookedModuleName=GetModuleNameFromAddress(currentAddress,allMods);} } } else if(currentAddress){ isHooked=true; hookedModuleName=GetModuleNameFromAddress(currentAddress,allMods);} if(isHooked){ SuspiciousIATEntry e; e.moduleName=moduleName; e.importedModuleName=importedModName; e.functionName=functionName; e.originalAddress=nullptr; e.currentAddress=currentAddress; e.isHooked=true; out.push_back(e);} oft++; ft++; } iid++; } return out; }

bool ScanAllModulesForIATHooks(){ auto modules=GetAllProcessModules(); bool hooks=false; int total=0; std::vector<SuspiciousIATEntry> all; Logger::Log(LOG_INFO,std::string(IAT_LOG_PREFIX)+" Starting IAT Hook scan for "+std::to_string(modules.size())+" modules..."); for(auto& m:modules){ if(DetectionController::IsStopRequested()) break; auto sus=ScanModuleIAT(m); if(!sus.empty()){ hooks=true; total+=(int)sus.size(); all.insert(all.end(),sus.begin(),sus.end()); } } if(hooks){ std::string dumpPath=Config::Get().logFolder+"\\iat_hooks_dump.txt"; std::ofstream dump(dumpPath,std::ios::app); if(dump.is_open()){ dump<<"==== IAT Hook Scan Result ====\n"; dump<<"Total Hooks: "<<total<<"\n"; for(auto& e:all){ dump<<e.moduleName<<" | import: "<<e.importedModuleName<<" | func: "<<e.functionName<<" | addr: 0x"<<std::hex<<(uintptr_t)e.currentAddress<<std::dec<<"\n"; } } Logger::Log(LOG_DETECTED,std::string(IAT_LOG_PREFIX)+" Detected "+std::to_string(total)+" suspicious IAT entries (see iat_hooks_dump.txt)"); } else { Logger::Log(LOG_INFO,std::string(IAT_LOG_PREFIX)+" Scan completed. No hooks detected."); } return hooks; }

void ContinuousIATHookScan(){ auto& cfg=Config::Get(); Logger::Log(LOG_INFO,std::string(IAT_LOG_PREFIX)+" IAT Hook Scanner started"); SleepWithStopSeconds(cfg.iatInitialDelaySec); if(DetectionController::IsStopRequested()) return; if(ScanAllModulesForIATHooks()){ DetectionController::ReportDetection("IAT hooks detected at startup"); return; } while(!DetectionController::IsStopRequested()){ SleepWithStopSeconds(cfg.iatIntervalSec); if(DetectionController::IsStopRequested()) break; if(ScanAllModulesForIATHooks()){ DetectionController::ReportDetection("IAT hooks detected during runtime"); break; } } Logger::Log(LOG_INFO,std::string(IAT_LOG_PREFIX)+" IAT Hook Scanner thread exiting"); }